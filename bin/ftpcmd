#!/bin/sh
#
# ftpfiles()
#   Send website files to web server by ftp over SSL3.
#   Intended to be ultra-portable, but this is untested.
#
#
# REQUIREMENTS:
#   * A version of the 'curl' program supporting SSL3 (otherwise modify script)
#   * If you need to apply a transformation to the files before transferring:
#       write permissions for a temp directory (see below to set it)
#       or permission to create the temp directory
#   * If you like to end your filenames in newlines, you're out of luck. The
#       use of $( ... ) strips all trailing newlines.
#
# Intented to be resistant against evil filenames, but this is untested.
#
# The encryption mechanism for ftp.conf uses aes256. This is only 
# secure if aes256 is secure against 'known-plaintext attacks',
# because the ftp.conf uses a predictable format.
#
# TODO:
#   * Is shift a bashism?
#   * POSIX script for when there is no dirname command available
#   * Currently assumes that it is running on a machine which uses linux file endings ('\n')

usage() {
cat <<EOF
Usage: ftpcmd [opts] [file list|glob list]
 
The ftpcmd program searches in the directory of each file for a file named ftp.conf. If it is not found, it recursively searches parent directories until it finds such a file. The ftp.conf is then decrypted using openssl aes256. The default (symmetric) password file is ~/.ssh/id_rsa, but a password file can be supplied on the command line or the user can enter a password directly.

Some effort has been made to make ftpcmd:

* portable: bash-isms have been avoided
* secure: variables are quoted, printf preferred to echo, etc.

BUT NO GUARANTEES ARE MADE.

An example configuration file:

  [server_label]
  host=x.x.x.x
  username=...
  password=...
  remote_eof=win
  remote_dir=/path/to/remote/project/root
  preprocessor=../bin/escape-xml-values.sh

* No extra spaces (e.g., 'host = 1.1.1.1' is not allowed)
* No quotes (e.g., 'password="hello world"' should be 'password=hello world')
* The server label is arbitrary, but must begin with a-z, A-Z or _
* Multiple server configurations may be placed in a single file
* remote_eof may be 'win' (\\r\\n) or 'default' (\\n) or 'old_mac' (\\r) (without qutoes)
* remote_dir should begin with a / . The / directory translates to the default login directory for the given user configured on the ftp server
* preprocessor is evaluated relative to the directory containing ftp.conf

Converting Local to Remote Paths

The directory which contains the found ftp.conf file is used as the base directory for relativizing local paths. The 'remote_dir' property in ftp.conf is used as the base directory for relativizing remote paths. 

For example, if 'ftpcmd www/js/script.js' is invoked from the directory

  /home/user/src/myproject

then this script will search in the 'js' folder for a file named ftp.conf. Assume there is no such file, but that there is an ftp.conf located at

  /home/user/src/myproject/www/ftp.conf

This file will be read for the configuration. Assume it specifies

  remote_dir=/inetpub/wwwroot/dev/myproject

In this case, the file

  /home/user/src/myproject/www/js/script.js

would be transferred to

  [FTP_ROOT_DIR]/inetpub/wwwroot/dev/myproject/js/script.js

Command Line Options

  -c CONFIG_NAME
    Use the configuration in ftp.conf called CONFIG_NAME. Default is 'default'.

  -f
    Use the program 'ftp' to transfer the files. (Default)

  -h
    Print this message and exit.

  -k PRIVATE_KEY_FILE
    Specifies to use PRIVATE_KEY_FILE to decrypt ftp.conf connection information. Default is '~/.ssh/id_rsa'.

  -n
    The configuration file is not encrypted; it is plaintext.

  -p
    Decrypt ftp.conf by prompting for a password instead of using the ssh PRIVATE_KEY_FILE.

  -u
    Use the program 'curl' to transfer the files.

NOTE: Does not transfer (ignores) files named 'ftp.conf'.
EOF
}

# encode string for url (very portable implementation)
urlencode() {
  printf %s "$1" \
    | sed \
      -e 's/%/%25/g' \
      -e 's/ /%20/g' \
      -e 's/</%3C/g' \
      -e 's/>/%3E/g' \
      -e 's/#/%23/g' \
      -e 's/{/%7B/g' \
      -e 's/}/%7D/g' \
      -e 's/|/%7C/g' \
      -e 's/@/%40/g' \
      -e 's/=/%3D/g' \
      -e 's/&/%26/g' \
      -e 's/~/%7E/g' \
      -e 's/`/%60/g' \
      -e 's/;/%3B/g' \
      -e 's/?/%3F/g' \
      -e 's/:/%3A/g' \
      -e 's:/:%2F:g' \
      -e 's:\\:%5C:g' \
      -e 's:\^:%5E:g' \
      -e 's:\[:%5B:g' \
      -e 's:\]:%5D:g' \
      -e 's:\$:%24:g' \
      -e 's:\!:%21:g' \
      -e 's:\*:%2A:g'
}

# usage: find_config "/path/to/file"
# returns: full path of ftp.conf
# for relative paths, call from the dir from which the script was called!
find_config() {
  SAVE_DIR=$(pwd)
  cd $(dirname "$1")
  PREV_DIR=
  CURR_DIR="$(pwd -P)"
  while [ "$CURR_DIR" != "$PREV_DIR" ]; do
    if [ -e 'ftp.conf' ]; then
      printf "%s/ftp.conf" "$(pwd -P)"
      # restore original directory
      cd "$SAVE_DIR"
      return
    fi
    cd ..
    PREV_DIR="$CURR_DIR"
    CURR_DIR="$(pwd -P)"
  done
  # restore original directory
  cd "$SAVE_DIR"
}

# readconf "$(cat ftp.conf)" "$CONFIG_NAME" "$CONFIG_VAR"
# $CONFIG_NAME: e.g., 'default' means search for [default] header in ftp.conf
# $CONFIG_VAR: e.g., 'username' means return value of username variable
readconf() {
  CONFIG_VAL=
  IN_CONFIG=false
  printf %s\\n "$1" | while read line; do
    if LC_ALL=C printf %s "$line" | grep -q "^\[$2\]"; then
      # in the request config specified by arg 5
      IN_CONFIG=true
    elif "$IN_CONFIG"; then
      if LC_ALL=C printf %s "$line" | grep -q "^\["; then
        # now in a different config
        IN_CONFIG=false
      else
        # in the requested config
        if [ "$(printf %s $line | cut -d '=' -f 1)" = "$3" ]; then
          printf %s "$line" | sed -e "s/${3}=//g"
        fi
      fi
    fi
  done | tail -1
}

# connection string to root remote user or ftp directory
readconf_conn() {
  USERNAME=$(readconf "$1" "$2" 'username')
  PASSWORD=$(readconf "$1" "$2" 'password')
  HOST=$(readconf "$1" "$2" 'host')

  printf "%s" $(urlencode "$USERNAME"):$(urlencode "$PASSWORD")@"$HOST":/
}

encrypt_openssl() {
  #--cacert /etc/ssl/certs/cert.pem
  openssl enc -e -aes-256-cbc -in "$1";
}

decrypt_openssl() {
  openssl enc -d -aes-256-cbc -d -in "$1";
}

# encrypt_ssh [FILE_TO_ENCRYPT] [SSH_PRIVATE_KEY_FILENAME]
encrypt_ssh() {
  cat "$2" | openssl enc -aes-256-cbc -pass stdin -in "$1"
}

# decrypt_ssh [FILE_TO_DECRYPT] [SSH_PRIVATE_KEY_FILENAME]
decrypt_ssh() {
  cat "$2" | openssl enc -aes-256-cbc -pass stdin -d -in "$1"
}

encrypt_gpg() {
  cat "$1" \
    | GPG_AGENT_INFO="" \
      gpg --cipher-algo aes256 -e -o- - 2>/dev/null;
}

decrypt_gpg() {
  cat "$1" \
    | GPG_AGENT_INFO="" \
      gpg --cipher-algo aes256 -d -o- - 2>/dev/null;
} 

dircount() { printf %s "$1" | tr /\\n \\n/ | wc -l ; }
matchstr() { case "$1" in "$2") return 0 ;; *) return 1 ;; esac ; }

unregex() {
  sed -e 's/[]\/()$*.^|[]/\\&/g' <<< "$1"
}

rev_str() {
  if [ "$1" = "" ]; then
    STRING_TO_REVERSE=$(cat /dev/stdin)
  else
    STRING_TO_REVERSE="$1"
  fi
  printf %s "$STRING_TO_REVERSE" | awk '
  { 
    n = split($0, arr, ""); 
    for(i=1; i<=n; i++) s = arr[i] s;
  } 
  END { print s; }'
}

file_ext() {
  printf "%s" $(rev_str "$1" | cut -d '.' -f 1 | rev_str)
}

absolute_path() {
  if [ -d "$@" ]; then
    printf "%s" $(cd "$@" && pwd -P)
  else
    printf "%s" $(cd $(dirname "$@") && pwd -P)/$(basename "$@")
  fi
}

# IN PLACE: convert *nix text files to windows overwriting original
nix2win_in_place() {
  sed -i -e 's/$/\r/' "$1"
}
# WITH BACKUP: convert *nix text files to windows saving original
nix2win_with_bak() {
  mkdir -p "$2"
  for fn in $(ls $(printf %s "$1")); do
    sed -e 's/$/\r/' "$fn" > "$2"/"$fn"
  done 
}

# IN PLACE: convert *nix text files to mac overwriting original
nix2mac_in_place() {
  perl -i -ape 's/\r/\n/g;' $(printf %s "$1")
}
# WITH BACKUP: convert *nix text files to mac saving original
nix2mac_with_bak() {
  perl -i.bak -ape 's/\r/\n/g;' $(printf %s "$1")
}

# IN PLACE: convert windows text files to *nix overwriting original
win2nix_in_place() {
  sed -i -e 's/\r//g' $(printf %s "$1")
}
# WITH BACKUP: convert windows text files to *nix saving original
win2nix_with_bak() {
  sed -i.bak -e 's/\r//g' $(printf %s "$1")
}

# IN PLACE: convert mac text files to *nix overwriting original
mac2nix_in_place() {
  perl -i -ape 's/\n/\r/g;' $(printf %s "$1")
}
# WITH BACKUP: convert mac text files to *nix saving originals
mac2nix_with_bak() {
  perl -i.bak -ape 's/\n/\r/g;' $(printf %s "$1")
}

# OVERWRITE: file.ext with file.ext.bak
restore_backups() {
  for fn in $(ls "$1"/*.bak); do
    mv $fn "$1"/$(basename -s '.bak' $fn)
  done
}

NEWLINE="

"
  
SCRIPT_PATH=$(pwd -P)

# Default options
CONFIG_LABEL='default'
CONFIG_ENC='ssh'
SEND_USING='curl'
ID_FILE=~/.ssh/id_rsa

if [ "$#" = "0" ]; then
  usage
  exit 1
fi

# Clear these variables
unset OPTIND nextopt
while getopts 'c:fhk:npu' nextopt; do
  case "$nextopt" in
    c)
      CONFIG_LABEL="$OPTARG"
      ;;
    f)
      SEND_USING='ftp'
      ;;
    h)
      usage
      exit 0
      ;;
    k)
      CONFIG_ENC='ssh'
      ID_FILE="$OPTARG"
      ;;
    n)
      CONFIG_ENC='none'
      KEY_FILE=
      ;;
    p)
      CONFIG_ENC='ssl'
      ;;
    u)
      SEND_USING='curl'
      ;;
    *)
      usage
      exit 1
      ;;
  esac
done

# shift out the switches and read the arguments (files to send)
shift $(($OPTIND-1))

# temp folder for holding modified files for transfer
tmpdir="tmp$(date +%s)"
if ! mkdir -p "$tmpdir" ; then
  printf "could not make temp directory: '%s'\\n" "$tmpdir"
  printf "aborting.\\n"
  exit 2
fi

find "$@" -type f | while read fn
do
  # don't allow (presumably accidental) transfer of ftp.conf
  if [ "$(basename $fn)" != "ftp.conf" ]; then
    fn_absolute=$(absolute_path "$fn")

    # find configuration file
    PREV_CONF_FILENAME="$CONF_FILENAME"
    CONF_FILENAME="$(find_config "$fn_absolute")"

    # if using a different configuration file
    if [ "$PREV_CONF_FILENAME" != "$CONF_FILENAME" ]; then
      # read configuration file, decrypting if necessary
      if [ "$CONFIG_ENC" = "none" ]; then
        conf_text="$(cat $CONF_FILENAME)"
      elif [ "$CONFIG_ENC" = "ssh" ]; then
        conf_text=$(decrypt_ssh "$CONF_FILENAME" "$ID_FILE")
      else
        conf_text=$(decrypt_openssl "$CONF_FILENAME")
      fi
    fi

    # compute root dir for transferring this particular file
    FILE_ROOT_DIR="$(dirname $CONF_FILENAME)"
    REMOTE_ROOT_DIR="$(readconf "$conf_text" "$CONFIG_LABEL" 'remote_dir')"

    # compute path relative to folder containing configuration file
    REL_DIR_REGEX="s/^$(unregex $FILE_ROOT_DIR)\/\(.*\)$/\1/g"
    fn_relative=$(sed -e "$REL_DIR_REGEX" <<< "$fn_absolute")
    mkdir -p "$tmpdir/$(dirname $fn_relative)"

    # get preprocessor
    PREPROCESSOR=$(readconf "$conf_text" "$CONFIG_LABEL" 'preprocessor')
    if [ "$PREPROCESSOR" = "" ]; then
      PREPROCESSOR='cat'
    else
      case "$PREPROCESSOR" in
      /*)
        ;;
      *)
        PREPROCESSOR="$FILE_ROOT_DIR"/"$PREPROCESSOR"
      esac
    fi
    # preprocess
    cat "$fn" | "$PREPROCESSOR" > "$tmpdir/$fn_relative"

    # get local eof type
    local_eof=default
    # get remote eof type
    remote_eof=$(readconf "$conf_text" "$CONFIG_LABEL" 'remote_eof')
    if [ "$remote_eof" = "" ]; then
      remote_eof=default
    fi
    if [ "$local_eof" = "default" ] && [ "$remote_eof" = "win" ]; then
      nix2win_in_place "$tmpdir/$fn_relative"
    fi

    USER=$(readconf "$conf_text" "$CONFIG_LABEL" 'username')
    PASS=$(readconf "$conf_text" "$CONFIG_LABEL" 'password')
    HOST=$(readconf "$conf_text" "$CONFIG_LABEL" 'host')

    # add to transfer command
    if [ "$SEND_USING" = "curl" ]; then
      # transfer
      curl -3 -v --disable-epsv --ftp-skip-pasv-ip --ftp-ssl --user "$USER:$PASS"\
          -T "$tmpdir/$fn_relative" \
          "ftp://${HOST}/${REMOTE_ROOT_DIR}/$fn_relative"
    else
      TRANS_CMD="put \"$tmpdir/$fn_relative\" \"$REMOTE_ROOT_DIR/$fn_relative\""
      ftp -inv "$HOST" << EOF

user "$USER" "$PASS"

cd $REMOTE_ROOT_DIR

binary

$TRANS_CMD

bye
EOF
    fi
  fi

done

# only deletes directory if it is empty
rm -r "$tmpdir"
